<?php
// $Id$

/**
 * Implements hook_help().
 */
function search_api_facets_help($path, array $arg) {
  if ($path == 'admin/config/search/search_api/index/%/facets') {
    return t('Select the indexed fields for which you want to create facet blocks. ' .
        'Before facet blocks are actually displayed, you will have to enable and configure them at the <a href="!url">block administration page</a>.',
        array('!url' => url('admin/structure/block')));
  }
}

/**
 * Implements hook_menu().
 */
function search_api_facets_menu() {
  $items['admin/config/search/search_api/index/%search_api_index/facets'] = array(
    'title' => 'Facets',
    'description' => 'Select the facet blocks to display.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('search_api_facets_index_select', 5),
    'access arguments' => array('administer search_api'),
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
    'file' => 'search_api_facets.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function search_api_facets_theme() {
  $themes['search_api_facets_form_table'] = array(
    'render element' => 'element',
    'file' => 'search_api_facets.admin.inc',
  );
  $themes['search_api_facets_list'] = array(
    'variables' => array(
      'terms' => array(),
      'active' => array(),
    ),
    'file' => 'search_api_facets.theme.inc',
  );
  $themes['search_api_facets_facet'] = array(
    'variables' => array(
      'name' => '',
      'count' => 0,
      'path' => NULL,
      'options' => array(),
      'active' => FALSE,
    ),
    'file' => 'search_api_facets.theme.inc',
  );

  return $themes;
}

/**
 * Implements hook_permission().
 */
function search_api_facets_permission() {
  return array(
    'use search_api_facets' => array(
      'title' => t('Use search facets'),
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function search_api_facets_block_info() {
  $blocks = array();
  $facets = search_api_facet_load(array('enabled' => TRUE));
  foreach ($facets as $facet) {
    $blocks[$facet->delta]['info'] = $facet->name;
    // It will hardly ever be possible to cache facet blocks sensibly.
    $blocks[$facet->delta]['cache'] = DRUPAL_NO_CACHE;
    // Use this so facet blocks are initially grouped together.
    $blocks[$facet->delta]['weight'] = 5;
  }
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function search_api_facets_block_configure($delta = '') {
  $facet = search_api_facet_load($delta);
  if (!$facet) {
    return array();
  }
  $index = search_api_index_load($facet->index_id);
  if (!$index || empty($index->options['fields'][$facet->field])) {
    drupal_set_message(t("This facet's index field is unknown."), 'error');
    return array();
  }
  $field = $index->options['fields'][$facet->field];
  $options = $facet->options;

  $form['#element_validate'][] = 'search_api_facets_block_configure_validate';
  $form['index_description'] = array(
    '#type' => 'item',
    '#title' => t('Search index'),
    '#description' => l($index->name, 'admin/config/search/search_api/index/' . $index->id),
  );
  $form['field_description'] = array(
    '#type' => 'item',
    '#title' => t('Field'),
    '#description' => check_plain($field['name']),
  );
  $form['limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of terms'),
    '#description' => t('The maximum number of facet terms to be displayed in this block. Leave blank or set to 0 for no limit.'),
    '#default_value' => $options['limit'],
  );
  $form['min_count'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum result count'),
    '#description' => t('The minimum number of results a facet value has to have in order to be displayed.'),
    '#default_value' => $options['min_count'],
  );
  $form['sort'] = array(
    '#type' => 'select',
    '#title' => t('Order'),
    '#options' => array(
      'count' => t('Order by result count'),
      'name' => t('Order by name'),
    ),
    '#default_value' => $options['sort'],
  );
  $form['missing'] = array(
    '#type' => 'checkbox',
    '#title' => t('Include "missing" facet'),
    '#description' => t('Include a facet term for all results without a value for this field.'),
    '#default_value' => $options['missing'],
  );

  $search_ids = variable_get('search_api_facets_search_ids', array());
  if (empty($search_ids[$index->id]) || count($search_ids[$index->id]) <= 1) {
    $form['default_true'] = array(
      '#type' => 'value',
      '#value' => $options['default_true'],
    );
    $form['ids_list'] = array(
      '#type' => 'value',
      '#value' => $options['ids_list'],
    );
  }
  else {
    $form['default_true'] = array(
      '#type' => 'select',
      '#title' => t('Display for searches'),
      '#options' => array(
        TRUE => t('For all except the selected'),
        FALSE => t('Only for the selected'),
      ),
      '#default_value' => $options['default_true'],
    );
    $form['ids_list'] = array(
      '#type' => 'select',
      '#title' => t('Search IDs'),
      '#options' => $search_ids[$index->id],
      '#size' => min(4, count($search_ids[$index->id])),
      '#multiple' => TRUE,
      '#default_value' => $options['ids_list'],
    );
  }

  $form['facet'] = array(
    '#type' => 'value',
    '#value' => $facet,
  );

  return $form;
}

/**
 * Validation function for search_api_facets_block_configure().
 */
function search_api_facets_block_configure_validate(array $element, array &$form_state) {
  $limit = $element['limit']['#value'];
  if ($limit && (!is_numeric($limit) || $limit < 0 || strpos($limit, '.') !== FALSE)) {
    form_error($element['limit'], t('The number of terms has to be a non-negative integer, or left blank.'));
  }
  $min_count = $element['min_count']['#value'];
  if (!$min_count || !is_numeric($min_count) || $min_count <= 0 || strpos($min_count, '.') !== FALSE) {
    form_error($element['min_count'], t('The minimum count has to be a positive integer.'));
  }
}

/**
 * Implements hook_block_save().
 */
function search_api_facets_block_save($delta = '', array $edit = array()) {
  $facet = $edit['facet'];
  $options = $facet->options;
  // We refresh the options each time the form is saved. Similar behaviour
  // exists for modules, menus, blocks and themes, so – why not?
  if (empty($options['type']) || $options['type'] == 'options') {
    _search_api_facets_refresh_type($facet, $options);
  }
  if ($options != $facet->options) {
    $facet->options = $options;
    search_api_facet_save($facet);
  }
}

/**
 * Implements hook_block_view().
 */
function search_api_facets_block_view($delta = '') {
  if (!user_access('use search_api_facets')) {
    return;
  }
  // Since we already computed the active facets when altering the search queries, we don't do it again here.
  $search_ids = drupal_static('search_api_facets_search_api_query_alter', array());
  if (empty($search_ids[$delta]) || !search_api_current_search($search_ids[$delta])) {
    return;
  }
  $search_id = $search_ids[$delta];
  list($query, $results) = search_api_current_search($search_id);
  $index = $query->getIndex();

  $facet = search_api_facet_load($delta);
  $options = $facet->options;

  // Get active facet filters for this query.
  $num = count(search_api_current_search());
  $params = drupal_get_query_parameters();
  $filter_name = $num > 1 ? 'filter_' . $search_id : 'filter';
  $filters = isset($params[$filter_name]) ? $params[$filter_name] : array();
  if (!$filters && $num == 1 && isset($params['filter_' . $search_id])) {
    $filter_name = 'filter_' . $search_id;
    $filters = $params[$filter_name];
  }
  $filters = empty($filters[$facet->field]) ? array() : $filters[$facet->field];

  // Bail early if there is nothing to do.
  if (empty($results['search_api_facets'][$delta]) && empty($filters)) {
    return;
  }

  // Get type information for later name-generation.
  if (empty($options['type'])) {
    _search_api_facets_refresh_type($facet, $options);
    $facet->options = $options;
    search_api_facet_save($facet);
  }
  $type = $options['type'];
  $values = isset($options['options']) ? $options['options'] : array();

  // Process available facet terms.
  $terms = empty($results['search_api_facets'][$delta]) ? array() : $results['search_api_facets'][$delta];
  foreach ($terms as $i => &$term) {
    $term = (object) $term;
    $term->name = _search_api_create_filter_name($term->filter, $type, $values);
    $term->iname = drupal_strtolower($term->name);
    if (!empty($params[$filter_name][$facet->field]) && array_search($term->filter, $params[$filter_name][$facet->field]) !== FALSE) {
      unset($terms[$i]);
      continue;
    }
    $term->params = $params;
    $term->params[$filter_name][$facet->field][] = $term->filter;
  }
  unset($term);
  if ($terms && $options['sort'] == 'name') {
    usort($terms, '_search_api_facets_compare_iname');
  }

  // Process active facet filters.
  $active = array();
  foreach ($filters as $i => $v) {
    $filter = new stdClass();
    $filter->name = _search_api_create_filter_name($v, $type, $values);
    $filter->params = $params;
    unset($filter->params[$filter_name][$facet->field][$i]);
    $active[] = $filter;
  }

  $theme_suffix  = '';
  $theme_suffix .= '__' . preg_replace('/\W+/', '_', $query->getIndex()->entity_type);
  $theme_suffix .= '__' . preg_replace('/\W+/', '_', $facet->field);
  $theme_suffix .= '__' . preg_replace('/\W+/', '_', $facet->delta);
  $theme = array(
    '#theme'  => 'search_api_facets_list' . $theme_suffix,
    '#terms'  => array(),
    '#active' => array(),
  );

  foreach ($terms as $term) {
    $theme['#terms'][] = array(
      '#theme'   => 'search_api_facets_facet' . $theme_suffix,
      '#name'    => $term->name,
      '#count'   => $term->count,
      '#path'    => $_GET['q'],
      '#options' => array('query' => $term->params),
      '#active'  => FALSE,
    );
  }
  foreach ($active as $filter) {
    $theme['#active'][] = array(
      '#theme'   => 'search_api_facets_facet' . $theme_suffix,
      '#name'    => $filter->name,
      '#count'   => 0,
      '#path'    => $_GET['q'],
      '#options' => array('query' => $filter->params),
      '#active'  => TRUE,
    );
  }

  return array(
    'subject' => $facet->name,
    'content' => $theme,
  );
}

/**
 * Implements hook_search_api_query_alter().
 */
function search_api_facets_search_api_query_alter(SearchApiQueryInterface $query) {
  if (!user_access('use search_api_facets')) {
    return;
  }
  // Add facet fields to query.
  $facets = search_api_facet_load(array('index_id' => $query->getIndex()->id, 'b.status' => 1));
  $fields = array();
  // Save the active facets for later retrieval when generating blocks.
  $active = &drupal_static(__FUNCTION__, array());
  $search_id = $query->getOption('search id');
  foreach ($facets as $facet) {
    if (array_search($search_id, $facet->options['ids_list']) === FALSE) {
      $search_ids = variable_get('search_api_facets_search_ids', array());
      if (empty($search_ids[$query->getIndex()->id][$search_id])) {
        // Remember this search ID.
        $search_ids[$query->getIndex()->id][$search_id] = $search_id;
        variable_set('search_api_facets_search_ids', $search_ids);
      }
      if (!$facet->options['default_true']) {
        break; // Facet doesn't match.
      }
    }
    elseif ($facet->options['default_true']) {
      break; // Facet doesn't match.
    }
    $active[$facet->delta] = $search_id;
    $fields[$facet->delta] = array(
      'field'     => $facet->field,
      'limit'     => $facet->options['limit'],
      'min_count' => $facet->options['min_count'],
      'missing'   => $facet->options['missing'],
    );
  }
  if ($fields) {
    $old = $query->setOption('search_api_facets', $fields);
    if ($old) { // This will only happen if other modules add facets of their own.
      $query->setOption('search_api_facets', $fields + $old);
    }
  }

  // Add active facet filters.
  $filter_array = search_api_facets_get_filters($query);
  foreach ($filter_array as $field => $filters) {
    foreach ($filters as $filter) {
      if ($filter == '!') {
        $query->condition($field, NULL);
      }
      elseif ($filter[0] = '"') {
        $filter = substr($filter, 1, -1);
        if ($filter) {
          $query->condition($field, $filter);
        }
      }
      else {
        $lowtype = $filter[0];
        $uptype = $filter[strlen($filter) - 1];
        $filter = substr($filter, 1, -1);
        list($lower, $upper) = explode(' ', $filter, 2);
        if ($lower == '*' && $upper == '*') {
          $query->condition($field, NULL, '<>');
        }
        else {
          if ($lower != '*') {
            $query->condition($field, $lower, $lowtype == '[' ? '>=' : '>');
          }
          if ($upper != '*') {
            $query->condition($field, $upper, $uptype == ']' ? '<=' : '<');
          }
        }
      }
    }
  }
}

/**
 * Implements hook_search_api_index_update().
 */
function search_api_facets_search_api_index_update(SearchApiIndex $index, $op = 'edit') {
  $id = $index->id;
  if ($op == 'enable') {
    if (db_query('SELECT COUNT(1) FROM {search_api_facet} WHERE index_id = :id', array(':id' => $id))->fetchField()) {
      drupal_set_message(t('There are saved facets for this index. ' .
          'Go to the <a href="!url">facet page</a> to enable them.',
          array('!url' => 'admin/config/search/search_api/index/' . $id . '/facets')));
    }
  }
  elseif ($op == 'disable') {
    $count = db_update('search_api_facet')
      ->fields(array('enabled' => FALSE))
      ->condition('index_id', $id)
      ->execute();
    if ($count) {
      drupal_set_message(t('The disabled index still had active facet blocks. They were deactivated.'), 'warning', FALSE);
    }
  }
  elseif ($op == 'fields') {
    $fields = $index->options['fields'];
    $facets = search_api_facet_load(array('index_id' => $id, 'enabled' => TRUE));
    foreach ($facets as $facet) {
      if (empty($fields[$facet->field]['indexed'])) {
        $facet->enabled = FALSE;
        search_api_facet_save($facet);
      }
      elseif (empty($facet->options['type']) || $facet->options['type'] != $fields[$facet->field]['type']) {
        _search_api_facets_refresh_type($facet, $facet->options);
        search_api_facet_save($facet);
      }
    }
  }
}

/**
 * Implements hook_search_api_index_delete().
 */
function search_api_facets_search_api_index_delete(SearchApiIndex $index) {
  db_delete('search_api_facet')
    ->condition('index_id', $index->id)
    ->execute();
}

/**
 * Implements hook_flush_caches().
 *
 * Refreshes type information for all enabled facets.
 */
function search_api_facets_flush_caches() {
  foreach (search_api_facet_load(array('enabled' => TRUE)) as $facet) {
    if (empty($facet->options['type']) || $facet->options['type'] == 'options') {
      _search_api_facets_refresh_type($facet, $facet->options);
      search_api_facet_save($facet);
    }
  }
}

/**
 * Load one or more facets. Either the block delta or an array of conditions
 * might be given.
 *
 * @param $conditions
 *   Either a facet's delta, or an array containing conditions in the form
 *   $field => $value for the facets to be returned. An empty array will return
 *   all defined facets.
 *   The special key "b.status" can be used in an array to specify the facet's
 *   corresponding {block}.status (in the current theme).
 * @param $reset
 *   If set to TRUE, the returned facets will be freshly loaded, instead of
 *   being loaded from the cache.
 *
 * @return stdClass
 *   Either the facet with the specified delta, or an array of facets matching
 *   the specified conditions, keyed by delta.
 */
function search_api_facet_load($conditions = array(), $reset = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());
  $key = serialize($conditions);
  if (!isset($cache[$key]) || $reset) {
    if (is_scalar($conditions)) {
      $delta = $conditions;
      $f = db_query('SELECT * FROM {search_api_facet} WHERE delta = :delta', array(':delta' => $delta))->fetch();
      if ($f) {
        $f->options = $f->options ? unserialize($f->options) : array();
      }
      $cache[$key] = $f;
    }
    else {
      $select = db_select('search_api_facet', 'f');
      $select->fields('f');
      foreach ($conditions as $field => $value) {
        if ($field == 'b.status') {
          global $theme;
          $select->join('block', 'b', 'b.module = :module AND b.delta = f.delta AND b.theme = :theme AND b.status = :status',
              array(':module' => 'search_api_facets', ':theme' => $theme, ':status' => $value));
          continue;
        }
        $select->condition($field, $value);
      }
      $facets = $select->execute()->fetchAllAssoc('delta');
      foreach ($facets as $facet) {
        $facet->options = $facet->options ? unserialize($facet->options) : array();
        $cache[serialize($facet->delta)] = $facet;
      }
      $cache[$key] = $facets;
    }
  }
  return $cache[$key];
}

/**
 * Saves a facet.
 * If $facet->delta is empty, it will be computed automatically. In this case,
 * or if $facet->is_new is set, the facet will be inserted. Otherwise, it will
 * be updated.
 *
 * @param stdClass $facet
 *   The facet object to save.
 */
function search_api_facet_save(stdClass $facet) {
  // Always set default options.
  $facet->options += array(
    'limit'        => 10,
    'min_count'    => 1,
    'sort'         => 'count',
    'missing'      => TRUE,
    'default_true' => TRUE,
    'ids_list'     => array(),
    'type'         => '',
  );
  if (!empty($facet->delta) && empty($facet->is_new)) {
    drupal_write_record('search_api_facet', $facet, 'delta');
    if ($facet->enabled != search_api_facet_load($facet->delta, TRUE)->enabled) {
      block_flush_caches();
    }
    return;
  }
  if (empty($facet->delta)) {
    // Construct a delta using index id and field.
    // We have to ensure that it's both unique and at most 32 characters long,
    // leading to a bit of complexity.
    $delta = 'index' . $facet->index_id . '_' . preg_replace('/\W+/', '_', $facet->field);
    $base = $delta = substr($delta, 0, 32);
    $i = 0;
    while (db_query('SELECT COUNT(1) FROM {search_api_facet} WHERE delta = :delta', array(':delta' => $delta))->fetchField()) {
      $suffix = '_' . ++$i;
      $delta = substr($base, 0, 32 - strlen($suffix)) . $suffix;
    }
    $facet->delta = $delta;
  }
  drupal_write_record('search_api_facet', $facet);
  if ($facet->enabled) {
    block_flush_caches();
  }
}

/**
 * Deletes one or more facets.
 *
 * @param $conditions
 *   Analogous to search_api_facet_load(), this can be either a facet delta or
 *   an array of conditions.
 *
 * @return
 *   TRUE, if any facets were successfully deleted, FALSE otherwise.
 */
function search_api_facet_delete($conditions = array()) {
  if (is_scalar($conditions)) {
    $delta = $conditions;
    return db_delete('search_api_facet')
      ->condition('delta', $delta)
      ->execute() != 0;
  }
  $del = db_delete('search_api_facet');
  foreach ($conditions as $field => $value) {
    $del->condition($field, $value);
  }
  if ($del->execute()) {
    block_flush_caches();
    return TRUE;
  }
  return FALSE;
}

/**
 * Function for retrieving the active filters for a certain search.
 *
 * Filters are taken from URL parameters named "filter_ID", or just "filter"
 * when only one facetted search is active.
 *
 * @param SearchApiQueryInterface $query
 *   The query for which to create the filters.
 *
 * @return array
 *   An array with field names as keys, mapped to a filter value.
 */
function search_api_facets_get_filters(SearchApiQueryInterface $query) {
  $params = drupal_get_query_parameters();
  $search_id = $query->getOption('search id');

  if (isset($search_id) && isset($params['filter_' . $search_id])) {
    $filters = $params['filter_' . $search_id];
  }
  elseif (isset($params['filter'])) {
    $filters = $params['filter'];
  }
  return empty($filters) ? array() : $filters;
}

/**
 * Refresh the type information in the given options array.
 *
 * @param stdClass $facet
 *   The facet whose type information should be refreshed.
 * @param array $options
 *   An array for which 'type' and, if applicable, 'options' will be set.
 */
function _search_api_facets_refresh_type(stdClass $facet, array &$options) {
  $index = search_api_index_load($facet->index_id);
  $type = $index->options['fields'][$facet->field]['type'];
  $options['type'] = search_api_extract_inner_type($type);
  $wrapper = entity_metadata_wrapper($index->entity_type);
  foreach (explode(':', $facet->field) as $part) {
    if (!isset($wrapper->$part)) {
      $wrapper = NULL;
      break;
    }
    $wrapper = $wrapper->$part;
  }
  if ($wrapper && $wrapper->optionsList()) {
    $options['type'] = 'options';
    $options['options'] = $wrapper->optionsList();
  }
}

/**
 * Creates a human-readable name for a certain filter. $values is only needed if
 * $type is "options".
 */
function _search_api_create_filter_name($filter, $type, array $values = array()) {
  if ($filter == '!') {
    return t('None');
  }
  if ($filter[0] == '"') {
    $filter = substr($filter, 1, -1);
    if ($filter == '' || $filter == '*') {
      return t('Any');
    }
    return _search_api_create_value_name($filter, $type, $values);
  }
  $lowtype = $filter[0];
  $uptype = $filter[strlen($filter) - 1];
  $filter = substr($filter, 1, -1);
  $filter = explode(' ', $filter, 2);
  if ($filter[0] == '*' && $filter[1] == '*') {
    return t('Any');
  }
  if ($filter[0] == '*') {
    return ($uptype == ']' ? '< ' : '≤ ') . _search_api_create_value_name($filter[1], $type, $values);
  }
  if ($filter[1] == '*') {
    return ($lowtype == ']' ? '> ' : '≥ ') . _search_api_create_value_name($filter[0], $type, $values);
  }
  return _search_api_create_value_name($filter[0], $type, $values) . ' – ' . _search_api_create_value_name($filter[1], $type, $values);
}

/**
 * Creates a human-readable name for a single filter value. $values is only
 * needed if $type is "options".
 */
function _search_api_create_value_name($value, $type, array $values = array()) {
  switch ($type) {
    case 'boolean':
      return $value ? t('True') : t('False');
    case 'date':
      // @todo Implement something really clever here. hook_date_types()?
      return format_date($value, 'short');
    case 'duration':
      return format_interval($value);
    case 'options':
      return empty($values[$value]) ? $value : $values[$value];

    default:
      // Nothing we can do about it.
      return $value;
  }
}

/**
 * Compares two object by their "iname" properties.
 */
function _search_api_facets_compare_iname(stdClass $term1, stdClass $term2) {
  return strcmp($term1->iname, $term2->iname);
}
