<?php
/**
 * @file
 * Contains the Search API hook implementations.
 */

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\TypedData\ComplexDataInterface;
use Drupal\search_api\Entity\Index;
use Drupal\search_api\Entity\Server;
use Drupal\search_api\Server\ServerInterface;
use Drupal\search_api\Utility\Utility;

/*
 * Constant definitions.
 */

/*
 * Hook implementations.
 */

/**
 * Implements hook_permission().
 */
function search_api_permission() {
  return array(
    'administer search_api' => array(
      'title' => t('Administer Search API'),
      'description' => t('Create and configure Search API servers and indexes.'),
    ),
  );
}

/**
 * Implements hook_entity_insert().
 *
 * Adds an entry to the tracking table for each index that tracks entities of
 * this type.
 */
function search_api_entity_insert(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {
    /** @var $storage \Drupal\search_api\IndexStorageInterface */
    $storage = \Drupal::entityManager()->getStorage('search_api_index');
    $indexes = $storage->getIndexesForEntity($entity);

    foreach ($indexes as $index) {
      if ($index->status()) {
        $index->getDatasource()->trackInsert(array($entity->id()));
      }
    }
  }
}

/**
 * Implements hook_entity_update().
 *
 * Updates the entry to the tracking table for each index that tracks this
 * entity.
 */
function search_api_entity_update(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {
    /** @var $storage \Drupal\search_api\IndexStorageInterface */
    $storage = \Drupal::entityManager()->getStorage('search_api_index');
    $indexes = $storage->getIndexesForEntity($entity);

    foreach ($indexes as $index) {
      if ($index->status()) {
        $index->getDatasource()->trackUpdate(array($entity->id()));
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Deletes the entry from the tracking table for each index that tracks this
 * entity.
 */
function search_api_entity_delete(EntityInterface $entity) {
  // Check if the entity is a content entity.
  if ($entity instanceof ContentEntityInterface) {
    /** @var $storage \Drupal\search_api\IndexStorageInterface */
    $storage = \Drupal::entityManager()->getStorage('search_api_index');
    $indexes = $storage->getIndexesForEntity($entity);

    foreach ($indexes as $index) {
      if ($index->status()) {
        $index->getDatasource()->trackDelete(array($entity->id()));
      }
    }
  }
}

/**
 * Implements hook_entity_operation_alter().
 *
 * @todo rewrite it regarding to https://drupal.org/node/1839516
 * @todo Should it be moved to SearchApiController->buildRow() ?
 */
function search_api_entity_operation_alter(array &$operations, EntityInterface $entity) {
  if (($entity->getEntityTypeId() == 'search_api_index' || $entity->getEntityTypeId() == 'search_api_server')
    && !$entity->status() && !empty($operations['enable'])) {
    if ($entity->getEntityTypeId() == 'search_api_index') {
      $operations['enable']['route_name'] = 'search_api.index_bypass_enable';
    }
    else {
      $operations['enable']['route_name'] = 'search_api.server_bypass_enable';
    }

    $operations['enable']['route_parameters']['token'] = \Drupal::csrfToken()->get($entity->id());
  }
}

/**
 * Determines whether a field of the given type contains text data.
 *
 * @deprecated
 *
 * @param string $type
 *   A string containing the type to check.
 * @param array $allowed
 *   Optionally, an array of allowed types.
 *
 * @return bool
 *   TRUE if $type is either one of the specified types, or a list of such
 *   values. FALSE otherwise.
 */
function search_api_is_text_type($type, array $allowed = array('text')) {
  return Utility::isTextType($type, $allowed);
}

/**
 * Checks whether it is possible to sort on fields of the given type.
 *
 * @deprecated
 *
 * @param $type
 *   The type to check for.
 *
 * @todo
 *   Make sure you take the field object and check the isMultiple parameter
 *
 * @return bool
 *   TRUE if this type is sortable, FALSE otherwise.
 */
function search_api_is_sortable_type($type) {
  return Utility::isSortableType($type);
}

/**
 * Returns all field types recognized by the Search API framework.
 *
 * @deprecated
 *
 * @return array
 *   An associative array with all recognized types as keys, mapped to their
 *   translated display names.
 *
 * @see search_api_default_index_types()
 * @see search_api_get_data_type_info()
 */
function search_api_data_types() {
  return Utility::getDataTypes();
}

/**
 * Get the mapping between data types and field types
 *
 * @deprecated
 *
 * @return array
 *   $mapping array with the field type that is requested and it's default data type for a sensible default
 */
function search_api_field_type_mapping() {
  return Utility::getFieldTypeMapping();
}

/**
 * Returns the default field types recognized by the Search API framework.
 *
 * @deprecated
 *
 * @return array
 *   An associative array with the default types as keys, mapped to their
 *   translated display names.
 */
function search_api_default_data_types() {
  return Utility::getDefaultDataTypes();
}

/**
 * Returns either all custom field type definitions, or a specific one.
 *
 * @deprecated
 *
 * @param $type
 *   If specified, the type whose definition should be returned.
 *
 * @return array
 *   If $type was not given, an array containing all custom data types, in the
 *   format specified by hook_search_api_data_type_info().
 *   Otherwise, the definition for the given type, or NULL if it is unknown.
 *
 * @see hook_search_api_data_type_info()
 */
function search_api_get_data_type_info($type = NULL) {
  return Utility::getDataTypeInfo($type);
}

/**
 * Extracts specific field values from a complex data object.
 *
 * @deprecated
 *
 * @param \Drupal\Core\TypedData\ComplexDataInterface $item
 *   The item from which fields should be extracted.
 * @param array $fields
 *   The fields to extract, passed by reference. The format is the same as the
 *   "fields" sub-array in the index options, i.e., an array with the field
 *   names as keys and arrays of field information as values, at least
 *   containing a "type" key. "value" and "original_type" keys will be added for
 *   all fields.
 */
function search_api_extract_fields(ComplexDataInterface $item, array &$fields) {
  Utility::extractFields($item, $fields);
}

/**
 * Adds an entry into a server's list of pending tasks.
 *
 * @deprecated
 *
 * @param \Drupal\search_api\Server\ServerInterface $server
 *   The server for which a task should be remembered.
 * @param $type
 *   The type of task to perform.
 * @param \Drupal\search_api\Index\IndexInterface|string|null $index
 *   (optional) If applicable, the index to which the task pertains (or its
 *   machine name).
 * @param mixed $data
 *   (optional) If applicable, some further data necessary for the task.
 */
function search_api_server_tasks_add(ServerInterface $server, $type, $index = NULL, $data = NULL) {
  return $server->tasksAdd($type, $index, $data);
}

/**
 * Removes pending server tasks from the list.
 *
 * @deprecated
 *
 * @param array|null $ids
 *   (optional) The IDs of the pending server tasks to delete. Set to NULL
 *   to not filter by IDs.
 * @param \Drupal\search_api\Server\ServerInterface|null $server
 *   (optional) A server for which the tasks should be deleted. Set to NULL to
 *   delete tasks from all servers.
 * @param \Drupal\search_api\Index\IndexInterface|string|null $index
 *   (optional) An index (or its machine name) for which the tasks should be
 *   deleted. Set to NULL to delete tasks for all indexes.
 */
function server_api_server_tasks_delete(array $ids = NULL, ServerInterface $server = NULL, $index = NULL) {
  if ($server) {
    $server->tasksDelete($ids, $index);
  }
  else {
    Utility::serverTasksDeleteAll();
  }
}

/**
 * Implements hook_theme().
 */
function search_api_theme() {
  return array(
    'search_api_admin_fields_table' => array(
      'render element' => 'element',
      'file' => 'search_api.theme.inc',
    ),
    'search_api_server' => array(
      'variables' => array('server' => NULL),
      'file' => 'search_api.theme.inc',
    ),
    'search_api_index' => array(
      'variables' => array('index' => NULL),
      'file' => 'search_api.theme.inc',
    ),
  );
}

/**
 * Implements hook_entity_type_build().
 */
function search_api_entity_type_build(array &$entity_types) {
  /** @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  if (isset($entity_types['node'])) {
    $entity_types['node']->set('search_api_default_fields', array(
      'node:title' => array(
        'type' => 'string',
      ),
      'node:path' => array(
        'type' => 'string',
      ),
      'node:created' => array(
        'type' => 'date',
      ),
      'node:changed' => array(
        'type' => 'date',
      )
    ));
  }
}
